(*why3 prove -P alt-ergo*)

theory RechercheDicho


use int.Int
use int.ComputerDivision
use array.Array
use array.IntArraySorted
use ref.Ref
use option.Option

exception PasTrouve


let recherche_dicho (a: array int) (v: int) : (res: option int)
  requires { sorted a }
  ensures  { match res with
              | Some i -> 0 <= i < length a && a[i] = v
              | None -> forall i. 0 <= i < length a -> a[i] <> v
            end }
=
  let n = length a in
  let ref g = 0 in
  let ref d = n - 1 in
  while g <= d do
    (* gauche positif ou nul et droite inférieur à n *)
    invariant { 0 <= g && d < n }
    (* La valeur recherchée est entre gauche et droite, i.e.
       ∀ i∈[0, n-1],  a[i] = v ⇒ i∈[g, d] *)
    invariant { forall i. 0 <= i < n -> a[i] = v -> g <= i <= d }
    (* Le variant de boucle est la quantité droite - gauche*)
    variant { d - g }
    let m = g + div (d - g) 2 in
    if a[m] < v then
      g := m + 1
    else if a[m] > v then
      d := m - 1
    else
      return Some m
  done;
  return None

end
