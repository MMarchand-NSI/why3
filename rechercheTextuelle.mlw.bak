module RechercheTextuelle
    use int.Int
    use seq.Seq
    use option.Option

  (* Fonction qui vérifie si le motif correspond à partir de pos *)
  let check_match (texte: seq int) (motif: seq int) (pos: int) : bool
    requires { 0 <= pos }
    requires { pos + length motif <= length texte }
    requires { length motif > 0 }
    ensures  { result = true <-> match_at texte motif pos }
    ensures  { result = false <-> not (match_at texte motif pos) }
  =
    let ref j = 0 in
    
    while j < length motif && texte[pos + j] = motif[j] do
      invariant { 0 <= j <= length motif }
      invariant { forall k. 0 <= k < j -> texte[pos + k] = motif[k] }
      variant   { length motif - j }
      j <- j + 1
    done;
    
    if j = length motif then begin
      assert { forall k. 0 <= k < length motif -> texte[pos + k] = motif[k] };
      true
    end else begin
      assert { j < length motif /\ texte[pos + j] <> motif[j] };
      assert { not (match_at texte motif pos) };
      false
    end
  
  (* Recherche principale simplifiée *)
  let cherche_decoupe (from: int) (motif: seq int) (texte: seq int) : option int
    requires { 0 <= from <= length texte }
    requires { length motif > 0 }
    ensures  { match result with
               | Some i -> from <= i /\ i + length motif <= length texte /\ match_at texte motif i
               | None -> forall k. from <= k /\ k + length motif <= length texte -> not (match_at texte motif k)
               end }
  =
    let ref i = from in
    
    while i + length motif <= length texte do
      invariant { from <= i <= length texte - length motif + 1 }
      invariant { forall k. from <= k < i -> not (match_at texte motif k) }
      variant   { length texte - i }
      
      if check_match texte motif i then
        return Some i;
      
      i <- i + 1
    done;
    
    None
end

