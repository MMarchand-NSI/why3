module MergeSortList

  use  int.Int
  use  list.List
  use  list.Length
  use  list.SortedInt
  use  list.Append   
  use  list.Permut   
  use  list.Mem

  (* Fonctions auxiliaires - inchangées *)
  let rec taille (l:list int) : int
    variant { length l }
  = match l with
    | Nil -> 0
    | Cons _ xs ->
        1 + taille xs
    end

  let rec somme (l:list int) : int
    variant { length l }
  = match l with
    | Nil -> 0
    | Cons x xs ->
        x + somme xs
    end

  let rec fact (n:int) : int
    requires { n >= 0 }
    variant  { n }
    ensures  { result >= 1 }
  = if n = 0 then 1 else n * fact (n - 1)


(* --- Lemmes supplémentaires pour aider la preuve (sans 'head') --- *)

  lemma permut_refl: forall l: list int. permut l l
  lemma permut_sym: forall l1 l2: list int. permut l1 l2 -> permut l2 l1
  lemma permut_trans: forall l1 l2 l3: list int. permut l1 l2 -> permut l2 l3 -> permut l1 l3
  lemma permut_cons: forall x: int, l1 l2: list int. permut l1 l2 -> permut (Cons x l1) (Cons x l2)

  lemma append_assoc: forall l1 l2 l3: list int.
    (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3)

  lemma permut_append_right: forall l1 l2 l3: list int.
    permut l1 l2 -> permut (l1 ++ l3) (l2 ++ l3)
  lemma permut_append_left: forall l1 l2 l3: list int.
    permut l1 l2 -> permut (l3 ++ l1) (l3 ++ l2)

  lemma permut_snoc_cons: forall x: int, l: list int.
    permut (Cons x l) (l ++ (Cons x Nil))

  lemma permut_append_concat: forall l1 l2 l3 l4: list int.
    permut l1 l2 -> permut l3 l4 -> permut (l1 ++ l3) (l2 ++ l4)

  lemma append_cons_head: forall x:int, l1:list int, l2:list int.
    (Cons x l1) ++ l2 = Cons x (l1 ++ l2)

  (* Pour le tri *)
  lemma sorted_cons_all_le: forall x: int, l: list int.
    (forall y: int. mem y l -> x <= y) -> sorted l -> sorted (Cons x l)

  (* NOUVEAU LEMME : Relie la tête d'une liste triée à la propriété 'inférieur ou égal à tous les éléments' *)
  lemma head_le_all_elements_if_sorted: forall h:int, l:list int.
    l = Cons h _ -> sorted l -> (forall y:int. mem y l -> h <= y)
  (* Ce lemme peut être prouvé avec Sorted.head_le y (dans list.SortedInt)
     Si ce lemme timeout lui-même, il faudra s'assurer que list.SortedInt
     est bien importé et que ses axiomes sont bien utilisés. *)


  lemma sorted_cons_is_lower: forall x:int, l:list int.
    SortedInt.is_lower x l -> sorted l -> sorted (Cons x l)


let rec merge (l1:list int) (l2:list int) : list int
  requires { sorted l1 }
  requires { sorted l2 }
  ensures  { sorted result }
  variant  { length l1 + length l2 }
= match l1, l2 with
  | Nil, _ -> l2 // Simplifié
  | _, Nil -> l1 // Simplifié
  | Cons x1 r1, Cons x2 r2 ->
      if x1 <= x2 then
        let o = merge r1 l2 in
        assert { sorted o };
        assert { forall y. mem y o -> x1 <= y };
        Cons x1 o
      else
        let o = merge l1 r2 in
        assert { sorted o };
        assert { forall y. mem y o -> x2 <= y };
        Cons x2 o
  end


end