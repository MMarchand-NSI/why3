(*why3 prove -P alt-ergo *)

theory TriInsertion


use int.Int
use array.Array
use array.IntArraySorted
use array.ArrayPermut
use array.ArrayEq
use ref.Ref


let inserer_bonne_place (a: array int) (i: int)
  requires { 0 <= i < length a }
  requires { sorted_sub a 0 i }  (*T[0..i-1] trié*)
  ensures  { sorted_sub a 0 (i+1) }  (*T[0..i] trié*)
  ensures  { permut_all (old a) a} (* la sortie est une permutation de l'entrée *)

=
  let a_deplacer = a[i] in
  let ref j = i in
  while j > 0 && a[j - 1] > a_deplacer do
    invariant { 0 <= j <= i }
    (*quand on met a_deplacer à l'indice j, on a toujours une permutation du tableau initial*)
    invariant { permut_all (old a) a[j <- a_deplacer] }

    (*Le tableau est trié quand on ignore l'indice j*)
    invariant { forall k1 k2. 0 <= k1 <= k2 <= i -> k1 <> j -> k2 <> j -> a[k1] <= a[k2] }

    (* a_deplacer < T[j+1..i] *)
    invariant { forall k. j+1 <= k <= i -> a_deplacer < a[k] }
    variant { j }

    a[j] <- a[j - 1];
    j <- j - 1
  done;
  a[j] <- a_deplacer


let tri_insertion (a: array int)
  (* le tableau final est trié *)
  ensures  { sorted a }
  (* le tableau final est une permutation du tableau initial *)
  ensures { permut_all (old a) a }
=
  let n = length a in
  for i=1 to n-1 do
    invariant { sorted_sub a 0 i }
    invariant { permut_all (old a) a }

    inserer_bonne_place a i
  done;

end